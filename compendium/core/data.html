<h1>metaproject.data</h1>

<h2>DataSource</h2>

<h3>Usage</h3>
<code>var datasource = new metaproject.DataSource(base_url,
    options)</code>
<h4>base_url</h4>
<p>Root url which this datasource will use</p>

<h4>options</h4>

key - Field used as primary key, defaults to 'id'
model: metaproject.Model instance

<h3>Methods</h3>

<h4>datasource.create(data)</h4>
<p>Instantiates a new <code>options.model</code> with initial
    <code>data</code></p>

<h4>datasource.get(model or path, callback)</h4>
<p>GETs data</p>
<ul>
    <li>datasource.get('/', callback); // GET /</li>

    <li>datasource.get('/', { namespace: 'HA::Facebook' } , callback);
        // GET /?namespace=HA::Facebook
    </li>
    <li>datasource.get('/id', callback); // GET /id</li>
    <li>datasource.get('/id', { _fields: [ 'displayName', 'identifier']
        }, callback ); // GET
        /id?_fields[]=displayName&_fields[]=identifier
    </li>
    <li>datasource.get(modelInstance, callback); // GET /id
        (modelInstance[options.key])
    </li>
</ul>

<h4>datasource.on('event', callback)</h4>
<p>attachs an event handler to this datasource</p>

<h5>events</h5>

<code>changed</code> - on change, params
{ action: 'put', 'post', 'get' or 'delete',
data: response data }

<h4>datasource.post(data, callback)</h4>
POSTs data to <code>base_url</code>

<h4>datasource.put(id, data, callback)</h4>
PUTs data on /id

<h4>datasource.save(model, callback)</h4>
<p>Calls <code>datasource.put</code> if the key defined in <code>options.key</code>
    is set, or post if it is a new entry
</p>
<code>datasource.destroy(id or model, callback)</code>
DELETEs /id (or model[options.key])


<h3>datasource.Editor = function(callbacks)</h3>
<p>An Editor is a specialized controller that handles loading and saving
    data to this datasource</p>
<h4>Usage</h4>
<code>var editor = new datasource.Editor(callbacks);</code>
<h5>callbacks</h5>
{ close: when the editor is closed, after unloading the data,
destroy: when the loaded resource is deleted,
save: when data is saved }
<h4>methods</h4>
<h5>editor.create(data)</h5>
<p>Creates a new resource, with initial <code>data</code></p>
<code>editor.destroy()</code>
<p>Deletes de current resource</p>

<h5>editor.load(model or id)</h5>

<p>Loads a resource</p>

<h5>editor.close()</h5>
<p>Closes the current resource</p>

<h5>editor.save()</h5>
<p>Commits changes to the datasource</p>

<h3>datasource.Nav</h3>
<p>Used to navigate the datasource</p>
<h4>Usage</h4>


<code>var nav = new datasource.Nav(filter);</code>

<p>A Navigator object is an observable array which updates itself
    automatically when the filter changes</p>
<p>Data is also reloaded automatically when the underlying datasource
    emits a <code>changed</code> event (every delete, post, put), to
    change this behavior, set <code>nav._live = false;</code> after
    instantiating the Navigator
</p>

<h4>Properties</h4>

<h5>nav.loading()</h5>
<p>Observable, true if data is being loaded</p>

<h5>nav.filter()</h5>
<p>Observable, object with the query parameters</p>
<p>To set a new filter, use <code>nav.filter({ param1: 'value1', param2:
    'value2' });</code></p>
<p>To set a specific field use <code>nav.filter.set('field',
    'value');</code></p>

<h4>Nav observables</h4>
<p>A nav.observable is a dependent query that is updated then the filter
    changes</p>
<h5>Usage</h5>
<code>var observable = nav.observable(params, transform)</code>
<p>The observable <code>params</code> are merged with the navigator's
    filter and sent
    to the server whenever the filter changes</p>
<p>The optional <code>transform</code> callback, if specified, is used
    to transform the datasource response.</p>
<h5>Properties</h5>
<code>nav.observable.loading</code>
<p>Observable, true if data is being loaded</p>


<h2>metaproject.Model = function (defaults, mapping) {</h2>