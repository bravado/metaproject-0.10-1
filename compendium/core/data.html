<h2>metaproject.Model</h2>

<p>Models define Classes to interact with your data. Under the hood, it uses the 
<code>ko.mapping</code> plugin.</p>
<p>Quoting the <a target="_blank" href="#">Official Documentation</a>,</p>

<blockquote>Most applications need to fetch data from a backend server. Since 
the server doesn’t have any concept of observables, it will just supply a plain 
JavaScript object (usually serialized as JSON). The mapping plugin gives you a 
straightforward way to map that plain JavaScript object into a view model with 
the appropriate observables. This is an alternative to manually writing your own 
JavaScript code that constructs a view model based on some data you’ve fetched 
from the server.</blockquote>

<h3>The Model factory</h3>

<p>Model Classes are defined using the 
<code>metaproject.Model(defaults, mapping)</code> function. The 
<code>defaults</code> parameter expects an object with the default values 
for this entity.</p>

<pre>
var Calculator = metaproject.Model({
    val1: 0,
    val2: 0,
    sum: function() {
        return this.val1() + this.val2();
    }
});
</pre>

<p>Functions are mapped to computed observables, scoped to the current instance,
    this allows the programmer to return complex properties.
</p>
<p>Once defined, new objects may be instantiated.</p>

<pre>
var calc = new Calculator({ val1: 2, val2: 2 });

// Will alert "4"
alert(calc.sum());
</pre>

<h3>Model Mappings</h3>
<p>Sometimes it may be necessary to have more control over how the mapping is 
    performed. This is accomplished using <code>mapping</code> options. On this
    more complex example, we'll define a <code>Contact</code> Model, which has a 
    list of <code>Address</code> instances on the <code>addresses</code> field.
</p>

<pre>
var Address = metaproject.Model({
    street: null,
    number: null
});

var Contact = metaproject.Model({
    first_name: null,
    last_name: null,
    name: function() {
        return this.first_name() + " " + this.last_name();
    },
    addresses: []
}, {
    addresses: Address.mapper
});
</pre>



<h4>Model methods</h4>

<table class="table table-bordered">
    <tr>
        <th><code>bind(url)</code></th>
        <td>Binds this Model to a DataSource</td>
    </tr>
</table>


<p>The <code>mapping</code> parameter</p>

<h2>DataSource</h2>

<h3>Usage</h3>
<code>var datasource = new metaproject.DataSource(base_url,
    options)</code>
<h4>base_url</h4>
<p>Root url which this datasource will use</p>

<h4>options</h4>

key - Field used as primary key, defaults to 'id'
model: metaproject.Model instance

<h3>Methods</h3>

<h4>datasource.create(data)</h4>
<p>Instantiates a new <code>options.model</code> with initial
    <code>data</code></p>

<h4>datasource.get(model or path, callback)</h4>
<p>GETs data</p>
<ul>
    <li>datasource.get('/', callback); // GET /</li>

    <li>datasource.get('/', { namespace: 'HA::Facebook' } , callback);
        // GET /?namespace=HA::Facebook
    </li>
    <li>datasource.get('/id', callback); // GET /id</li>
    <li>datasource.get('/id', { _fields: [ 'displayName', 'identifier']
        }, callback ); // GET
        /id?_fields[]=displayName&_fields[]=identifier
    </li>
    <li>datasource.get(modelInstance, callback); // GET /id
        (modelInstance[options.key])
    </li>
</ul>

<h4>datasource.on('event', callback)</h4>
<p>attachs an event handler to this datasource</p>

<h5>events</h5>

<code>changed</code> - on change, params
{ action: 'put', 'post', 'get' or 'delete',
data: response data }

<h4>datasource.post(data, callback)</h4>
POSTs data to <code>base_url</code>

<h4>datasource.put(id, data, callback)</h4>
PUTs data on /id

<h4>datasource.save(model, callback)</h4>
<p>Calls <code>datasource.put</code> if the key defined in <code>options.key</code>
    is set, or post if it is a new entry
</p>
<code>datasource.destroy(id or model, callback)</code>
DELETEs /id (or model[options.key])


<h3>datasource.Editor = function(callbacks)</h3>
<p>An Editor is a specialized controller that handles loading and saving
    data to this datasource</p>
<h4>Usage</h4>
<code>var editor = new datasource.Editor(callbacks);</code>
<h5>callbacks</h5>
{ close: when the editor is closed, after unloading the data,
destroy: when the loaded resource is deleted,
save: when data is saved }
<h4>methods</h4>
<h5>editor.create(data)</h5>
<p>Creates a new resource, with initial <code>data</code></p>
<code>editor.destroy()</code>
<p>Deletes de current resource</p>

<h5>editor.load(model or id)</h5>

<p>Loads a resource</p>

<h5>editor.close()</h5>
<p>Closes the current resource</p>

<h5>editor.save()</h5>
<p>Commits changes to the datasource</p>

<h3>datasource.Nav</h3>
<p>Used to navigate the datasource</p>
<h4>Usage</h4>


<code>var nav = new datasource.Nav(filter);</code>

<p>A Navigator object is an observable array which updates itself
    automatically when the filter changes</p>
<p>Data is also reloaded automatically when the underlying datasource
    emits a <code>changed</code> event (every delete, post, put), to
    change this behavior, set <code>nav._live = false;</code> after
    instantiating the Navigator
</p>

<h4>Properties</h4>

<h5>nav.loading()</h5>
<p>Observable, true if data is being loaded</p>

<h5>nav.filter()</h5>
<p>Observable, object with the query parameters</p>
<p>To set a new filter, use <code>nav.filter({ param1: 'value1', param2:
    'value2' });</code></p>
<p>To set a specific field use <code>nav.filter.set('field',
    'value');</code></p>

<h4>Nav observables</h4>
<p>A nav.observable is a dependent query that is updated then the filter
    changes</p>
<h5>Usage</h5>
<code>var observable = nav.observable(params, transform)</code>
<p>The observable <code>params</code> are merged with the navigator's
    filter and sent
    to the server whenever the filter changes</p>
<p>The optional <code>transform</code> callback, if specified, is used
    to transform the datasource response.</p>
<h5>Properties</h5>
<code>nav.observable.loading</code>
<p>Observable, true if data is being loaded</p>


<h2>metaproject.Model = function (defaults, mapping) {</h2>