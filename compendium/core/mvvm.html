<h1>KnockoutJS and MVVM</h1>

<p>Knockout is a JavaScript library that helps you to create rich, responsive display and editor user interfaces with a clean underlying data model. Any time you have sections of UI that update dynamically (e.g., changing depending on the user’s actions or when an external data source changes), KO can help you implement it more simply and maintainably.</p>

<p>Knockout is built around three core features:</p>
<!-- 

esses dias eu descobri que tem um extender no ko para fazer o  observable triggar 
a atualização mesmo se o valor novo for idêntico ao anterior
ko.observable().extend({notify: always}) 05:05:41 PM
ops 05:05:49 PM
ko.observable().extend({notify: 'always'}) 05:05:52 PM
falta documentação disso 05:08:54 PM
e de um evento que é possível obter o valor anterior no subscribe: 05:09:09 PM
obs.subscribe(function(previousValue) {
        doSomething();
    }, undefined, 'beforeChange');
-->
<ol>
<li>Observables and dependency tracking</li>

<li>Declarative bindings</li>

<li>Templating</li>
</ol>

<p>On this page, you&#8217;ll learn about the first of these three. But before 
that, let&#8217;s examine the MVVM pattern and the concept of a 
<em>view model</em>.</p>

<h1 id='mvvm_and_view_models'>MVVM and View Models</h1>

<p><em>Model-View-View Model (MVVM)</em> is a design pattern for building user 
interfaces. It describes how you can keep a potentially sophisticated UI simple 
by splitting it into three parts:</p>

<ul>
<li>
<p>A <em>model</em>: your application&#8217;s stored data. This data represents 
objects and operations in your business domain (e.g., bank accounts that can 
perform money transfers) and is independent of any UI. When using KO, you will 
usually make Ajax calls to some server-side code to read and write this stored 
model data.</p>
</li>

<li>
<p>A <em>view model</em>: a pure-code representation of the data and operations 
on a UI. For example, if you&#8217;re implementing a list editor, your view 
model would be an object holding a list of items, and exposing methods to add 
and remove items.</p>

<p>Note that this is not the UI itself: it doesn&#8217;t have any concept of 
buttons or display styles. It&#8217;s not the persisted data model either - it 
holds the unsaved data the user is working with. When using KO, your view models
are pure JavaScript objects that hold no knowledge of HTML. Keeping the view 
model abstract in this way lets it stay simple, so you can manage more 
sophisticated behaviors without getting lost.</p>
</li>

<li>
<p>A <em>view</em>: a visible, interactive UI representing the state of the view
model. It displays information from the view model, sends commands to the view 
model (e.g., when the user clicks buttons), and updates whenever the state of 
the view model changes.</p>

<p>When using KO, your view is simply your HTML document with declarative 
bindings to link it to the view model. Alternatively, you can use templates that
generate HTML using data from your view model.</p>
</li>
</ul>

<p>To create a view model with KO, just declare any JavaScript object. For 
example,</p>

<pre><code>var myViewModel = {
    personName: &#39;Bob&#39;,
    personAge: 123
};</code></pre>

<p>You can then create a very simple <em>view</em> of this view model using a 
declarative binding. For example, the following markup displays the 
<code>personName</code> value:</p>

<pre>
<code>The name is &lt;span data-bind=&quot;text: personName&quot;&gt;&lt;/span&gt;
</code></pre>

<h2 id='activating_knockout'>Activating Knockout</h2>

<p>The <code>data-bind</code> attribute isn&#8217;t native to HTML, though it is
perfectly OK (it&#8217;s strictly compliant in HTML 5, and causes no problems 
with HTML 4 even though a validator will point out that it&#8217;s an 
unrecognized attribute). But since the browser doesn&#8217;t know what it means,
you need to activate Knockout to make it take effect.</p>

<p>To activate Knockout, add the following line to a <code>&lt;script&gt;</code>
block:</p>

<pre><code>ko.applyBindings(myViewModel);</code></pre>

<p>You can either put the script block at the bottom of your HTML document, or 
you can put it at the top and wrap the contents in a DOM-ready handler such as 
<a href='http://api.jquery.com/jQuery/#jQuery3'>jQuery&#8217;s <code>$</code> 
function</a>.</p>

<p>That does it! Now, your view will display as if you&#8217;d written the 
following HTML:</p>

<pre><code>The name is &lt;span&gt;Bob&lt;/span&gt;</code></pre>

<p>In case you&#8217;re wondering what the parameters to 
<code>ko.applyBindings</code> do,</p>

<ul>
<li>
<p>The first parameter says what view model object you want to use with the 
declarative bindings it activates</p>
</li>

<li>
<p>Optionally, you can pass a second parameter to define which part of the 
document you want to search for <code>data-bind</code> attributes. For example, 
<code>ko.applyBindings(myViewModel, document.getElementById(&#39;someElementId&#39;))</code>. 
This restricts the activation to the element with ID <code>someElementId</code> 
and its descendants, which is useful if you want to have multiple view models 
and associate each with a different region of the page.</p>
</li>
</ul>

<p>Pretty simple, really.</p>

<h1 id='observables'>Observables</h1>

<p>OK, you&#8217;ve seen how to create a basic view model and how to display one
of its properties using a binding. But one of the key benefits of KO is that it
updates your UI automatically when the view model changes. How can KO know when 
parts of your view model change? Answer: you need to declare your model properties as <em>observables</em>, because these are special JavaScript objects that can notify subscribers about changes, and can automatically detect dependencies.</p>

<p>For example, rewrite the preceding view model object as follows:</p>

<pre><code>var myViewModel = {
    personName: ko.observable(&#39;Bob&#39;),
    personAge: ko.observable(123)
};</code></pre>

<p>You don&#8217;t have to change the view at all - the same <code>data-bind</code> syntax will keep working. The difference is that it&#8217;s now capable of detecting changes, and when it does, it will update the view automatically.</p>

<h2 id='reading_and_writing_observables'>Reading and writing observables</h2>

<p>Not all browsers support JavaScript getters and setters (* cough * IE * cough *), so for compatibility, <code>ko.observable</code> objects are actually <em>functions</em>.</p>

<ul>
<li>
<p>To <strong>read</strong> the observable&#8217;s current value, just call the observable with no parameters. In this example, <code>myViewModel.personName()</code> will return <code>&#39;Bob&#39;</code>, and <code>myViewModel.personAge()</code> will return <code>123</code>.</p>
</li>

<li>
<p>To <strong>write</strong> a new value to the observable, call the observable and pass the new value as a parameter. For example, calling <code>myViewModel.personName(&#39;Mary&#39;)</code> will change the name value to <code>&#39;Mary&#39;</code>.</p>
</li>

<li>
<p>To write values to <strong>multiple observable properties</strong> on a model object, you can use <em>chaining syntax</em>. For example, <code>myViewModel.personName(&#39;Mary&#39;).personAge(50)</code> will change the name value to <code>&#39;Mary&#39;</code> <em>and</em> the age value to <code>50</code>.</p>
</li>
</ul>

<p>The whole point of observables is that they can be observed, i.e., other code can say that it wants to be notified of changes. That&#8217;s what many of KO&#8217;s built-in bindings do internally. So, when you wrote <code>data-bind=&quot;text: personName&quot;</code>, the <code>text</code> binding registered itself to be notified when <code>personName</code> changes (assuming it&#8217;s an observable value, which it is now).</p>

<p>When you change the name value to <code>&#39;Mary&#39;</code> by calling <code>myViewModel.personName(&#39;Mary&#39;)</code>, the <code>text</code> binding will automatically update the text contents of the associated DOM element. That&#8217;s how changes to the view model automatically propagate to the view.</p>

<h2 id='explicitly_subscribing_to_observables'>Explicitly subscribing to observables</h2>

<p><em>You won&#8217;t normally need to set up subscriptions manually, so beginners should skip this section.</em></p>

<p>For advanced users, if you want to register your own subscriptions to be notified of changes to observables, you can call their <code>subscribe</code> function. For example,</p>

<pre><code>myViewModel.personName.subscribe(function(newValue) {
    alert(&quot;The person&#39;s new name is &quot; + newValue);
});</code></pre>

<p>The <code>subscribe</code> function is how many parts of KO work internally. Most of the time you don&#8217;t need to use this, because the built-in bindings and templating system take care of managing subscriptions.</p>

<p>The <code>subscribe</code> function accepts three parameters: <code>callback</code> is the function that is called whenever the notification happens, <code>target</code> (optional) defines the value of <code>this</code> in the callback function, and <code>event</code> (optional; default is <code>&quot;change&quot;</code>) is the name of the event to receive notification for.</p>

<p>You can also terminate a subscription if you wish: first capture the return value as a variable, then you can call its <code>dispose</code> function, e.g.:</p>

<pre><code>var subscription = myViewModel.personName.subscribe(function(newValue) { /* do stuff */ });
// ...then later...
subscription.dispose(); // I no longer want notifications</code></pre>

<p>If you want to be notified of the previous value of an observable when it is changed, you can subscribe to the <code>beforeChange</code> event:</p>

<pre><code>myViewModel.personName.subscribe(function(oldValue) {
    alert(&quot;The person&#39;s previous name is &quot; + oldValue);
}, null, &quot;beforeChange&quot;);</code></pre>

<h2 id='forcing_observables_to_always_notify_subscribers'>Forcing observables to always notify subscribers</h2>

<p>When writing to an observable that contains a primitive value, the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in <code>notify</code> <a href='extenders.html'>extender</a> to ensure that an observable&#8217;s subscribers are always notified on a write, even if the value is the same. You would apply this extender to an observable like:</p>

<pre><code>myViewModel.personName.extend({ notify: &#39;always&#39; });</code></pre>    

<h1>Computed Observables</h1>	
		    	<p>What if you&#8217;ve got an <a href='observables.html'>observable</a> for <code>firstName</code>, and another for <code>lastName</code>, and you want to display the full name? That&#8217;s where <em>computed observables</em> come in - these are functions that are dependent on one or more other observables, and will automatically update whenever any of these dependencies change.</p>

<p>For example, given the following view model class,</p>

<pre><code>function AppViewModel() {
    this.firstName = ko.observable(&#39;Bob&#39;);
    this.lastName = ko.observable(&#39;Smith&#39;);
}</code></pre>

<p>&#8230; you could add a computed observable to return the full name:</p>

<pre><code>function AppViewModel() {
    // ... leave firstName and lastName unchanged ...

    this.fullName = ko.computed(function() {
        return this.firstName() + &quot; &quot; + this.lastName();
    }, this);
}</code></pre>

<p>Now you could bind UI elements to it, e.g.:</p>

<pre><code>The name is &lt;span data-bind=&quot;text: fullName&quot;&gt;&lt;/span&gt;</code></pre>

<p>&#8230; and they will be updated whenever <code>firstName</code> or <code>lastName</code> changes (your evaluator function will be called once each time any of its dependencies change, and whatever value you return will be passed on to the observers such as UI elements or other computed observables).</p>

<h3 id='managing_this'>Managing &#8216;this&#8217;</h3>

<p><em>Beginners may wish to skip this section - as long as you follow the same coding patterns as the examples, you won&#8217;t need to know or care about it!</em></p>

<p>In case you&#8217;re wondering what the second parameter to <code>ko.computed</code> is (the bit where we passed <code>this</code> in the preceding code), that defines the value of <code>this</code> when evaluating the computed observable. Without passing it in, it would not have been possible to refer to <code>this.firstName()</code> or <code>this.lastName()</code>. Experienced JavaScript coders will regard this as obvious, but if you&#8217;re still getting to know JavaScript it might seem strange. (Languages like C# and Java never expect the programmer to set a value for <code>this</code>, but JavaScript does, because its functions themselves aren&#8217;t part of any object by default.)</p>

<h4 id='a_popular_convention_that_simplifies_things'>A popular convention that simplifies things</h4>

<p>There&#8217;s a popular convention for avoiding the need to track <code>this</code> altogether: if your viewmodel&#8217;s constructor copies a reference to <code>this</code> into a different variable (traditionally called <code>self</code>), you can then use <code>self</code> throughout your viewmodel and don&#8217;t have to worry about it being redefined to refer to something else. For example:</p>

<pre><code>function AppViewModel() {
    var self = this;

    self.firstName = ko.observable(&#39;Bob&#39;);
    self.lastName = ko.observable(&#39;Smith&#39;);
    self.fullName = ko.computed(function() {
        return self.firstName() + &quot; &quot; + self.lastName();
    });
}</code></pre>

<p>Because <code>self</code> is captured in the function&#8217;s closure, it remains available and consistent in any nested functions, such as the <code>ko.computed</code> evaluator. This convention is even more useful when it comes to event handlers, as you&#8217;ll see in many of the <a href='../examples/'>live examples</a>.</p>

<h3 id='dependency_chains_just_work'>Dependency chains just work</h3>

<p>Of course, you can create whole chains of computed observables if you wish. For example, you might have:</p>

<ul>
<li>an <strong>observable</strong> called <code>items</code> representing a set of items</li>

<li>another <strong>observable</strong> called <code>selectedIndexes</code> storing which item indexes have been &#8216;selected&#8217; by the user</li>

<li>a <strong>computed observable</strong> called <code>selectedItems</code> that returns an array of item objects corresponding to the selected indexes</li>

<li>another <strong>computed observable</strong> that returns <code>true</code> or <code>false</code> depending on whether any of <code>selectedItems</code> has some property (like being new or being unsaved). Some UI element, like a button, might be enabled or disabled based on this value.</li>
</ul>

<p>Then, changes to <code>items</code> or <code>selectedIndexes</code> will ripple through the chain of computed observables, which in turn updates any UI bound to them. Very tidy and elegant.</p>

<h1 id='writeable_computed_observables'>Writeable computed observables</h1>

<p><em>Beginners may wish to skip this section - writeable computed observables are fairly advanced and are not necessary in most situations</em></p>

<p>As you&#8217;ve learned, computed observables have a value that is computed from other observables. In that sense, computed observables are normally <em>read-only</em>. What may seem surprising, then, is that it is possible to make computed observables <em>writeable</em>. You just need to supply your own callback function that does something sensible with written values.</p>

<p>You can then use your writeable computed observable exactly like a regular observable, with your own custom logic intercepting all reads and writes. This is a powerful feature with a wide range of possible uses. Just like observables, you can write values to multiple observable or computed observable properties on a model object using <em>chaining syntax</em>. For example, <code>myViewModel.fullName(&#39;Joe Smith&#39;).age(50)</code>.</p>

<h3 id='example_1_decomposing_user_input'>Example 1: Decomposing user input</h3>

<p>Going back to the classic &#8220;first name + last name = full name&#8221; example, you can turn things back-to-front: make the <code>fullName</code> computed observable writeable, so that the user can directly edit the full name, and their supplied value will be parsed and mapped back to the underlying <code>firstName</code> and <code>lastName</code> observables:</p>

<pre><code>function MyViewModel() {
    this.firstName = ko.observable(&#39;Planet&#39;);
    this.lastName = ko.observable(&#39;Earth&#39;);

    this.fullName = ko.computed({
        read: function () {
            return this.firstName() + &quot; &quot; + this.lastName();
        },
        write: function (value) {
            var lastSpacePos = value.lastIndexOf(&quot; &quot;);
            if (lastSpacePos &gt; 0) { // Ignore values with no space character
                this.firstName(value.substring(0, lastSpacePos)); // Update &quot;firstName&quot;
                this.lastName(value.substring(lastSpacePos + 1)); // Update &quot;lastName&quot;
            }
        },
        owner: this
    });
}

ko.applyBindings(new MyViewModel());</code></pre>

<p>In this example, the <code>write</code> callback handles incoming values by splitting the incoming text into &#8220;firstName&#8221; and &#8220;lastName&#8221; components, and writing those values back to the underlying observables. You can bind this view model to your DOM in the obvious way, as follows:</p>

<pre><code>&lt;p&gt;First name: &lt;span data-bind=&quot;text: firstName&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Last name: &lt;span data-bind=&quot;text: lastName&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Hello, &lt;input data-bind=&quot;value: fullName&quot;/&gt;!&lt;/h2&gt;</code></pre>

<p>This is the exact opposite of the <a href='../examples/helloWorld.html'>Hello World</a> example, in that here the first and last names are not editable, but the combined full name is editable.</p>

<p>The preceding view model code demonstrates the <em>single parameter syntax</em> for initializing computed observables. See the <a href='#computed_observable_reference'>computed observable reference</a> below for the full list of available options.</p>

<h3 id='example_2_a_value_converter'>Example 2: A value converter</h3>

<p>Sometimes you might want to represent a data point on the screen in a different format from its underlying storage. For example, you might want to store a price as a raw float value, but let the user edit it with a currency symbol and fixed number of decimal places. You can use a writeable computed observable to represent the formatted price, mapping incoming values back to the underlying float value:</p>

<pre><code>function MyViewModel() {
    this.price = ko.observable(25.99);

    this.formattedPrice = ko.computed({
        read: function () {
            return &#39;$&#39; + this.price().toFixed(2);
        },
        write: function (value) {
            // Strip out unwanted characters, parse as float, then write the raw data back to the underlying &quot;price&quot; observable
            value = parseFloat(value.replace(/[^\.\d]/g, &quot;&quot;));
            this.price(isNaN(value) ? 0 : value); // Write to underlying storage
        },
        owner: this
    });
}

ko.applyBindings(new MyViewModel());</code></pre>

<p>It&#8217;s trivial to bind the formatted price to a text box:</p>

<pre><code>&lt;p&gt;Enter bid price: &lt;input data-bind=&quot;value: formattedPrice&quot;/&gt;&lt;/p&gt;</code></pre>

<p>Now, whenever the user enters a new price, the text box immediately updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can&#8217;t enter more than two decimal places, because if they try to, the additional decimal places are immediately removed. Similarly, they can&#8217;t enter negative values, because the <code>write</code> callback strips off any minus sign.</p>

<h3 id='example_3_filtering_and_validating_user_input'>Example 3: Filtering and validating user input</h3>

<p>Example 1 showed how a writeable computed observable can effectively <em>filter</em> its incoming data by choosing not to write certain values back to the underlying observables if they don&#8217;t meet some criteria. It ignored full name values that didn&#8217;t include a space.</p>

<p>Taking this a step further, you could also toggle an <code>isValid</code> flag depending on whether the latest input was satisfactory, and display a message in the UI accordingly. There&#8217;s an easier way of doing validation (explained below), but first consider the following view model, which demonstrates the mechanism:</p>

<pre><code>function MyViewModel() {
    this.acceptedNumericValue = ko.observable(123);
    this.lastInputWasValid = ko.observable(true);

    this.attemptedValue = ko.computed({
        read: this.acceptedNumericValue,
        write: function (value) {
            if (isNaN(value))
                this.lastInputWasValid(false);
            else {
                this.lastInputWasValid(true);
                this.acceptedNumericValue(value); // Write to underlying storage
            }
        },
        owner: this
    });
}

ko.applyBindings(new MyViewModel());</code></pre>

<p>&#8230; with the following DOM elements:</p>

<pre><code>&lt;p&gt;Enter a numeric value: &lt;input data-bind=&quot;value: attemptedValue&quot;/&gt;&lt;/p&gt;
&lt;div data-bind=&quot;visible: !lastInputWasValid()&quot;&gt;That&#39;s not a number!&lt;/div&gt;</code></pre>

<p>Now, <code>acceptedNumericValue</code> will only ever contain numeric values, and any other values entered will trigger the appearance of a validation message instead of updating <code>acceptedNumericValue</code>.</p>

<p><strong>Note:</strong> For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its <code>number</code> class on the <code>&lt;input&gt;</code> element. Knockout and jQuery Validation work together nicely, as demonstrated on the <a href='../examples/gridEditor.html'>grid editor</a> example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</p>

<h1 id='how_dependency_tracking_works'>How dependency tracking works</h1>

<p><em>Beginners don&#8217;t need to know about this, but more advanced developers will want to know why we keep making all these claims about KO automatically tracking dependencies and updating the right parts of the UI&#8230;</em></p>

<p>It&#8217;s actually very simple and rather lovely. The tracking algorithm goes like this:</p>

<ol>
<li>Whenever you declare a computed observable, KO immediately invokes its evaluator function to get its initial value.</li>

<li>While your evaluator function is running, KO keeps a log of any observables (or computed observables) that your evaluator reads the value of.</li>

<li>When your evaluator is finished, KO sets up subscriptions to each of the observables (or computed observables) that you&#8217;ve touched. The subscription callback is set to cause your evaluator to run again, looping the whole process back to step 1 (disposing of any old subscriptions that no longer apply).</li>

<li>KO notifies any subscribers about the new value of your computed observable.</li>
</ol>

<p>So, KO doesn&#8217;t just detect your dependencies the first time your evaluator runs - it redetects them every time. This means, for example, that your dependencies can vary dynamically: dependency A could determine whether you also depend on B or C. Then, you&#8217;ll only be re-evaluated when either A or your current choice of B or C changes. You don&#8217;t have to declare dependencies: they&#8217;re inferred at runtime from the code&#8217;s execution.</p>

<p>The other neat trick is that declarative bindings are simply implemented as computed observables. So, if a binding reads the value of an observable, that binding becomes dependent on that observable, which causes that binding to be re-evaluated if the observable changes.</p>

<h3 id='controlling_dependencies_using_peek'>Controlling dependencies using peek</h3>

<p>Knockout&#8217;s automatic dependency tracking normally does exactly what you want. But you might sometimes need to control which observables will update your computed observable, especially if the computed observable performs some sort of action, such as making an Ajax request. The <code>peek</code> function lets you access an observable or computed observable without creating a dependency.</p>

<p>In the example below, a computed observable is used to reload an observable named <code>currentPageData</code> using Ajax with data from two other observable properties. The computed observable will update whenever <code>pageIndex</code> changes, but it ignores changes to <code>selectedItem</code> because it is accessed using <code>peek</code>. In this case, the user might want to use the current value of <code>selectedItem</code> only for tracking purposes when a new set of data is loaded.</p>

<pre><code>ko.computed(function() {
    var params = {
        page: this.pageIndex(),
        selected: this.selectedItem.peek()
    };
    $.getJSON(&#39;/Some/Json/Service&#39;, params, this.currentPageData);
}, this);</code></pre>

<p>Note: If you just want to prevent a computed observable from updating too often, see the <a href='throttle-extender.html'>throttle extender</a>.</p>

<h3 id='note_why_circular_dependencies_arent_meaningful'>Note: Why circular dependencies aren&#8217;t meaningful</h3>

<p>Computed observables are supposed to map a set of observable inputs into a single observable output. As such, it doesn&#8217;t make sense to include cycles in your dependency chains. Cycles would <em>not</em> be analogous to recursion; they would be analogous to having two spreadsheet cells that are computed as functions of each other. It would lead to an infinite evaluation loop.</p>

<p>So what does Knockout do if you have a cycle in your dependency graph? It avoids infinite loops by enforcing the following rule: <strong>Knockout will not restart evaluation of a computed while it is already evaluating</strong>. This is very unlikely to affect your code. It&#8217;s relevant in two situations: when two computed observables are dependent on each other (possible only if one or both use the <code>deferEvaluation</code> option), or when a computed observable writes to another observable on which it has a dependency (either directly or via a dependency chain). If you need to use one of these patterns and want to entirely avoid the circular dependency, you can use the <code>peek</code> function described above.</p>

<h1 id='determining_if_a_property_is_a_computed_observable'>Determining if a property is a computed observable</h1>

<p>In some scenarios, it is useful to programmatically determine if you are dealing with a computed observable. Knockout provides a utility function, <code>ko.isComputed</code> to help with this situation. For example, you might want to exclude computed observables from data that you are sending back to the server.</p>

<pre><code>for (var prop in myObject) {
  if (myObject.hasOwnProperty(prop) &amp;&amp; !ko.isComputed(myObject[prop])) {
      result[prop] = myObject[prop];
  }
}</code></pre>

<p>Additionally, Knockout provides similar functions that can operate on observables and computed observables:</p>

<ul>
<li><code>ko.isObservable</code> - returns true for observables, observableArrays, and all computed observables.</li>

<li><code>ko.isWriteableObservable</code> - returns true for observable, observableArrays, and writeable computed observables.</li>
</ul>

<h1 id='computed_observable_reference'>Computed Observable Reference</h1>

<p>A computed observable can be constructed using one of the following forms:</p>

<ol>
<li>
<p><code>ko.computed( evaluator [, targetObject, options] )</code> &#8212; This form supports the most common case of creating a computed observable.</p>

<ul>
<li><code>evaluator</code> &#8212; A function that is used to evaluate the computed observable&#8217;s current value.</li>

<li><code>targetObject</code> &#8212; If given, defines the value of <code>this</code> whenever KO invokes your callback functions. See the section on <a href='#managing_this'>managing <code>this</code></a> for more information.</li>

<li><code>options</code> &#8212; An object with further properties for the computed observable. See the full list below.</li>
</ul>
</li>

<li>
<p><code>ko.computed( options )</code> &#8212; This single parameter form for creating a computed observable accepts a JavaScript object with any of the following properties.</p>

<ul>
<li><code>read</code> &#8212; Required. A function that is used to evaluate the computed observable&#8217;s current value.</li>

<li><code>write</code> &#8212; Optional. If given, makes the computed observable writeable. This is a function that receives values that other code is trying to write to your computed observable. It&#8217;s up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</li>

<li><code>owner</code> &#8212; Optional. If given, defines the value of <code>this</code> whenever KO invokes your <code>read</code> or <code>write</code> callbacks.</li>

<li><code>deferEvaluation</code> &#8212; Optional. If this option is true, then the value of the computed observable will not be evaluated until something actually attempts to access it. By default, a computed observable has its value determined immediately during creation.</li>

<li><code>disposeWhen</code> &#8212; Optional. If given, this function is executed on each re-evaluation to determine if the computed observable should be disposed. A <code>true</code>-ish result will trigger disposal of the computed observable.</li>

<li><code>disposeWhenNodeIsRemoved</code> &#8212; Optional. If given, disposal of the computed observable will be triggered when the specified DOM node is removed by KO. This feature is used to dispose computed observables used in bindings when nodes are removed by the <code>template</code> and control-flow bindings.</li>
</ul>
</li>
</ol>

<p>A computed observable provides the following functions:</p>

<ul>
<li><code>dispose()</code> &#8212; Manually disposes the computed observable, clearing all subscriptions to dependencies. This function is useful if you want to stop a computed observable from being updated or want to clean up memory for a computed observable that has dependencies on observables that won&#8217;t be cleaned.</li>

<li><code>extend(extenders)</code> &#8212; Applies the given <a href='extenders.html'>extenders</a> to the computed observable.</li>

<li><code>getDependenciesCount()</code> &#8212; Returns the current number of dependencies of the computed observable.</li>

<li><code>getSubscriptionsCount()</code> &#8212; Returns the current number of subscriptions (either from other computed observables or manual subscriptions) of the computed observable.</li>

<li><code>isActive()</code> &#8212; Returns whether the computed observable may be updated in the future. A computed observable is inactive if it has no dependencies.</li>

<li><code>peek()</code> &#8212; Returns the current value of the computed observable without creating a dependency (see the section above on <a href='#controlling_dependencies_using_peek'><code>peek</code></a>).</li>

<li><code>subscribe( callback [,callbackTarget, event] )</code> &#8212; Registers a <a href='observables.html#explicitly_subscribing_to_observables'>manual subscription</a> to be notified of changes to the computed observable.</li>
</ul>

<h1>Observable Arrays</h1>	
		    	<p>If you want to detect and respond to changes on one object, you&#8217;d use <a href='observables.html'>observables</a>. If you want to detect and respond to changes of a <em>collection of things</em>, use an <code>observableArray</code>. This is useful in many scenarios where you&#8217;re displaying or editing multiple values and need repeated sections of UI to appear and disappear as items are added and removed.</p>

<h3 id='example'>Example</h3>

<pre><code>var myObservableArray = ko.observableArray();    // Initially an empty array
myObservableArray.push(&#39;Some value&#39;);            // Adds the value and notifies observers</code></pre>

<p>To see how you can bind the <code>observableArray</code> to a UI and let the user modify it, see <a href='../examples/simpleList.html'>the simple list example</a>.</p>

<h3 id='key_point_an_observablearray_tracks_which_objects_are_in_the_array_not_the_state_of_those_objects'>Key point: An observableArray tracks which objects are <em>in</em> the array, <em>not</em> the state of those objects</h3>

<p>Simply putting an object into an <code>observableArray</code> doesn&#8217;t make all of that object&#8217;s properties themselves observable. Of course, you can make those properties observable if you wish, but that&#8217;s an independent choice. An <code>observableArray</code> just tracks which objects it holds, and notifies listeners when objects are added or removed.</p>

<h2 id='prepopulating_an_observablearray'>Prepopulating an observableArray</h2>

<p>If you want your observable array <strong>not</strong> to start empty, but to contain some initial items, pass those items as an array to the constructor. For example,</p>

<pre><code>// This observable array initially contains three objects
var anotherObservableArray = ko.observableArray([
    { name: &quot;Bungle&quot;, type: &quot;Bear&quot; },
    { name: &quot;George&quot;, type: &quot;Hippo&quot; },
    { name: &quot;Zippy&quot;, type: &quot;Unknown&quot; }
]);</code></pre>

<h2 id='reading_information_from_an_observablearray'>Reading information from an observableArray</h2>

<p>Behind the scenes, an <code>observableArray</code> is actually an <a href='observables.html'>observable</a> whose value is an array (plus, <code>observableArray</code> adds some additional features described below). So, you can get the underlying JavaScript array by invoking the <code>observableArray</code> as a function with no parameters, just like any other observable. Then you can read information from that underlying array. For example,</p>

<pre><code>alert(&#39;The length of the array is &#39; + myObservableArray().length);
alert(&#39;The first element is &#39; + myObservableArray()[0]);</code></pre>

<p>Technically you can use any of the native JavaScript array functions to operate on that underlying array, but normally there&#8217;s a better alternative. KO&#8217;s <code>observableArray</code> has equivalent functions of its own, and they&#8217;re more useful because:</p>

<ol>
<li>They work on all targeted browsers. (For example, the native JavaScript <code>indexOf</code> function doesn&#8217;t work on IE 8 or earlier, but KO&#8217;s <code>indexOf</code> works everywhere.)</li>

<li>For functions that modify the contents of the array, such as <code>push</code> and <code>splice</code>, KO&#8217;s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated.</li>

<li>The syntax is more convenient. To call KO&#8217;s <code>push</code> method, just write <code>myObservableArray.push(...)</code>. This is slightly nicer than calling the underlying array&#8217;s <code>push</code> method by writing <code>myObservableArray().push(...)</code>.</li>
</ol>

<p>The rest of this page describes <code>observableArray</code>&#8217;s functions for reading and writing array information.</p>

<h3 id='indexof'>indexOf</h3>

<p>The <code>indexOf</code> function returns the index of the first array item that equals your parameter. For example, <code>myObservableArray.indexOf(&#39;Blah&#39;)</code> will return the zero-based index of the first array entry that equals <code>Blah</code>, or the value <code>-1</code> if no matching value was found.</p>

<h3 id='slice'>slice</h3>

<p>The <code>slice</code> function is the <code>observableArray</code> equivalent of the native JavaScript <code>slice</code> function (i.e., it returns the entries of your array from a given start index up to a given end index). Calling <code>myObservableArray.slice(...)</code> is equivalent to calling the same method on the underlying array (i.e., <code>myObservableArray().slice(...)</code>).</p>

<h2 id='manipulating_an_observablearray'>Manipulating an observableArray</h2>

<p><code>observableArray</code> exposes a familiar set of functions for modifying the contents of the array and notifying listeners.</p>

<h3 id='pop_push_shift_unshift_reverse_sort_splice'>pop, push, shift, unshift, reverse, sort, splice</h3>

<p>All of these functions are equivalent to running the native JavaScript array functions on the underlying array, and then notifying listeners about the change:</p>

<ul>
<li>
<p><code>myObservableArray.push(&#39;Some new value&#39;)</code> adds a new item to the end of array</p>
</li>

<li>
<p><code>myObservableArray.pop()</code> removes the last value from the array and returns it</p>
</li>

<li>
<p><code>myObservableArray.unshift(&#39;Some new value&#39;)</code> inserts a new item at the beginning of the array</p>
</li>

<li>
<p><code>myObservableArray.shift()</code> removes the first value from the array and returns it</p>
</li>

<li>
<p><code>myObservableArray.reverse()</code> reverses the order of the array</p>
</li>

<li>
<p><code>myObservableArray.sort()</code> sorts the array contents.</p>

<ul>
<li>By default, it sorts alphabetically (for strings) or numerically (for numbers).</li>

<li>Optionally, you can pass a function to control how the array should be sorted. Your function should accept any two objects from the array and return a negative value if the first argument is smaller, a positive value is the second is smaller, or zero to treat them as equal. For example, to sort an array of &#8216;person&#8217; objects by last name, you could write <code>myObservableArray.sort(function(left, right) { return left.lastName == right.lastName ? 0 : (left.lastName &lt; right.lastName ? -1 : 1) })</code></li>
</ul>
</li>

<li>
<p><code>myObservableArray.splice()</code> removes and returns a given number of elements starting from a given index. For example, <code>myObservableArray.splice(1, 3)</code> removes three elements starting from index position 1 (i.e., the 2nd, 3rd, and 4th elements) and returns them as an array.</p>
</li>
</ul>

<p>For more details about these <code>observableArray</code> functions, see the equivalent documentation of the <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2'>standard JavaScript array functions</a>.</p>

<h3 id='remove_and_removeall'>remove and removeAll</h3>

<p><code>observableArray</code> adds some more useful methods that aren&#8217;t found on JavaScript arrays by default:</p>

<ul>
<li><code>myObservableArray.remove(someItem)</code> removes all values that equal <code>someItem</code> and returns them as an array</li>

<li><code>myObservableArray.remove(function(item) { return item.age &lt; 18 })</code> removes all values whose <code>age</code> property is less than 18, and returns them as an array</li>

<li><code>myObservableArray.removeAll([&#39;Chad&#39;, 132, undefined])</code> removes all values that equal <code>&#39;Chad&#39;</code>, <code>123</code>, or <code>undefined</code> and returns them as an array</li>

<li><code>myObservableArray.removeAll()</code> removes all values and returns them as an array</li>
</ul>

<h3 id='destroy_and_destroyall_note_usually_relevant_to_ruby_on_rails_developers_only'>destroy and destroyAll (Note: Usually relevant to Ruby on Rails developers only)</h3>

<p>The <code>destroy</code> and <code>destroyAll</code> functions are mainly intended as a convenience for developers using Ruby on Rails:</p>

<ul>
<li><code>myObservableArray.destroy(someItem)</code> finds any objects in the array that equal <code>someItem</code> and gives them a special property called <code>_destroy</code> with value <code>true</code></li>

<li><code>myObservableArray.destroy(function(someItem) { return someItem.age &lt; 18 })</code> finds any objects in the array whose <code>age</code> property is less than 18, and gives those objects a special property called <code>_destroy</code> with value <code>true</code></li>

<li><code>myObservableArray.destroyAll([&#39;Chad&#39;, 132, undefined])</code> finds any objects in the array that equal <code>&#39;Chad&#39;</code>, <code>123</code>, or <code>undefined</code> and gives them a special property called <code>_destroy</code> with value <code>true</code></li>

<li><code>myObservableArray.destroyAll()</code> gives a special property called <code>_destroy</code> with value <code>true</code> to all objects in the array</li>
</ul>

<p>So, what&#8217;s this <code>_destroy</code> thing all about? It&#8217;s only really interesting to Rails developers. The convention in Rails is that, when you pass into an action a JSON object graph, the framework can automatically convert it to an ActiveRecord object graph and then save it to your database. It knows which of the objects are already in your database, and issues the correct INSERT or UPDATE statements. To tell the framework to DELETE a record, you just mark it with <code>_destroy</code> set to <code>true</code>.</p>

<p>Note that when KO renders a <code>foreach</code> binding, it automatically hides any objects marked with <code>_destroy</code> equal to <code>true</code>. So, you can have some kind of &#8220;delete&#8221; button that invokes the <code>destroy(someItem)</code> method on the array, and this will immediately cause the specified item to vanish from the visible UI. Later, when you submit the JSON object graph to Rails, that item will also be deleted from the database (while the other array items will be inserted or updated as usual).</p>    


<h1>The data-bind syntax</h1>	
		    	<p>Knockout&#8217;s declarative binding system provides a concise and powerful way to link data to the UI. It&#8217;s generally easy and obvious to bind to simple data properties or to use a single binding. For more complex bindings, it helps to better understand the behavior and syntax of Knockout&#8217;s binding system.</p>

<h3 id='binding_syntax'>Binding syntax</h3>

<p>A binding consists of two items, the binding <em>name</em> and <em>value</em>, separated by a colon. Here is an example of a single, simple binding:</p>

<pre><code>Today&#39;s message is: &lt;span data-bind=&quot;text: myMessage&quot;&gt;&lt;/span&gt;</code></pre>

<p>An element can include multiple bindings (related or unrelated), with each binding separated by a comma. Here are some examples:</p>

<pre><code>&lt;!-- related bindings: valueUpdate is a parameter for value --&gt;
Your value: &lt;input data-bind=&quot;value: someValue, valueUpdate: &#39;afterkeydown&#39;&quot; /&gt;

&lt;!-- unrelated bindings --&gt;
Cellphone: &lt;input data-bind=&quot;value: cellphoneNumber, enable: hasCellphone&quot; /&gt;</code></pre>

<p>The binding <em>name</em> should generally match a registered binding handler (either built-in or <a href='custom-bindings.html'>custom</a>) or be a parameter for another binding. If the name matches neither of those, Knockout will ignore it (without any error or warning). So if a binding doesn&#8217;t appear to work, first check that the name is correct.</p>

<h4 id='binding_values'>Binding values</h4>

<p>The binding <em>value</em> can be a single <a href='https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals'>value, variable, or literal</a> or almost any valid <a href='https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Expressions_and_Operators'>JavaScript expression</a>. Here are examples of various binding values:</p>

<pre><code>&lt;!-- variable (usually a property of the current view model --&gt;
&lt;div data-bind=&quot;visible: shouldShowMessage&quot;&gt;...&lt;/div&gt;

&lt;!-- comparison and conditional --&gt;
The item is &lt;span data-bind=&quot;text: price() &gt; 50 ? &#39;expensive&#39; : &#39;cheap&#39;&quot;&gt;&lt;/span&gt;.

&lt;!-- function call and comparison --&gt;
&lt;button data-bind=&quot;enable: parseAreaCode(cellphoneNumber()) != &#39;555&#39;&quot;&gt;...&lt;/button&gt;

&lt;!-- function expression --&gt;
&lt;div data-bind=&quot;click: function (data) { myFunction(&#39;param1&#39;, data) }&quot;&gt;...&lt;/div&gt;

&lt;!-- object literal (with unquoted and quoted property names) --&gt;
&lt;div data-bind=&quot;with: {emotion: &#39;happy&#39;, &#39;facial-expression&#39;: &#39;smile&#39;}&quot;&gt;...&lt;/div&gt;</code></pre>

<p>These examples show that the value can be just about any JavaScript expression. Even the comma is fine when it&#8217;s enclosed in braces, brackets, or parentheses. When the value is an object literal, the object&#8217;s property names must be valid JavaScript identifiers or be enclosed in quotes. If the binding value is an invalid expression or references an unknown variable, Knockout will output an error and stop processing bindings.</p>

<h4 id='whitespace'>Whitespace</h4>

<p>Bindings can include any amount of <em>whitespace</em> (spaces, tab, and newlines), so you&#8217;re free to use it to arrange your bindings as you like. The following examples are all equivalent:</p>

<pre><code>&lt;!-- no spaces --&gt;
&lt;select data-bind=&quot;options:availableCountries,optionsText:&#39;countryName&#39;,value:selectedCountry,optionsCaption:&#39;Choose...&#39;&quot;&gt;&lt;/select&gt;

&lt;!-- some spaces --&gt;
&lt;select data-bind=&quot;options : availableCountries, optionsText : &#39;countryName&#39;, value : selectedCountry, optionsCaption : &#39;Choose...&#39;&quot;&gt;&lt;/select&gt;

&lt;!-- spaces and newlines --&gt;
&lt;select data-bind=&quot;
    options: availableCountries,
    optionsText: &#39;countryName&#39;,
    value: selectedCountry,
    optionsCaption: &#39;Choose...&#39;&quot;&gt;&lt;/select&gt;</code></pre>

<h3 id='notes_for_multiple_bindings_on_a_single_element'>Notes for multiple bindings on a single element</h3>

<p>When you use multiple bindings on a single element, those bindings can interact. If this behavior surprises you, it&#8217;s worth bearing in mind the following current implementation details:</p>

<ol>
<li>
<p><strong>Bindings are applied in order from left to right.</strong> There are a few rare cases where bindings function correctly only when ordered in a certain way, because one reads a property that another writes. This is a limitation that we&#8217;re likely to eliminate in a future version of Knockout. At present, the full list is:</p>

<ul>
<li><code>attr: { value: ... }</code> or <code>value: ...</code> should be used before <code>checked: ...</code></li>

<li><code>options: ...</code> or <code>foreach: ...</code> should be used before <code>value: ...</code> or <code>selectedOptions: ...</code></li>
</ul>
</li>

<li>
<p><strong>When model values change, all bindings on the same element are updated together.</strong> For example, if you use <code>enable: allowEdits, value: someValue</code>, then both the <code>enable</code> and <code>value</code> bindings will be refreshed when either <code>allowEdits</code> or <code>someValue</code> changes. In some extreme cases this can lead to worse performance (<a href='http://www.knockmeout.net/2012/06/knockoutjs-performance-gotcha-3-all-bindings.html'>more info</a>). Don&#8217;t create custom bindings that rely on this implementation detail, because it&#8217;s a limitation we are likely to eliminate in a future version of Knockout.</p>
</li>
</ol>    


<h1>Binding context</h1>	
		    	<p>A <em>binding context</em> is an object that holds data that you can reference from your bindings. While applying bindings, Knockout automatically creates and manages a hierarchy of binding contexts. The root level of the hierarchy refers to the <code>viewModel</code> parameter you supplied to <code>ko.applyBindings(viewModel)</code>. Then, each time you use a control flow binding such as <a href='with-binding.html'><code>with</code></a> or <a href='foreach-binding.html'><code>foreach</code></a>, that creates a child binding context that refers to the nested view model data.</p>

<p>Bindings contexts offer the following special properties that you can reference in any binding:</p>

<ul>
<li>
<p><code>$parent</code></p>

<p>This is the view model object in the parent context, the one immeditely outside the current context. In the root context, this is undefined. Example:</p>

<pre><code>  &lt;h1 data-bind=&quot;text: name&quot;&gt;&lt;/h1&gt;

  &lt;div data-bind=&quot;with: manager&quot;&gt;
      &lt;!-- Now we&#39;re inside a nested binding context --&gt;
      &lt;span data-bind=&quot;text: name&quot;&gt;&lt;/span&gt; is the
      manager of &lt;span data-bind=&quot;text: $parent.name&quot;&gt;&lt;/span&gt;
  &lt;/div&gt;</code></pre>
</li>

<li>
<p><code>$parents</code></p>

<p>This is an array representing all of the parent view models:</p>

<p><code>$parents[0]</code> is the view model from the parent context (i.e., it&#8217;s the same as <code>$parent</code>)</p>

<p><code>$parents[1]</code> is the view model from the grandparent context</p>

<p><code>$parents[2]</code> is the view model from the great-grandparent context</p>

<p>&#8230; and so on.</p>
</li>

<li>
<p><code>$root</code></p>

<p>This is the main view model object in the root context, i.e., the topmost parent context. It is equivalent to <code>$parents[$parents.length - 1]</code>.</p>
</li>

<li>
<p><code>$data</code></p>

<p>This is the view model object in the current context. In the root context, <code>$data</code> and <code>$root</code> are equivalent. <code>$data</code> is useful when you don&#8217;t want to reference a property on the viewmodel, but instead want to reference the viewmodel itself. Example:</p>

<pre><code>  &lt;ul data-bind=&quot;foreach: [&#39;cats&#39;, &#39;dogs&#39;, &#39;fish&#39;]&quot;&gt;
      &lt;li&gt;The value is &lt;span data-bind=&quot;text: $data&quot;&gt;&lt;/span&gt;&lt;/li&gt;
  &lt;/ul&gt;</code></pre>
</li>

<li>
<p><code>$index</code> (only available within <code>foreach</code> bindings)</p>

<p>This is the zero-based index of the current array entry being rendered by a <code>foreach</code> binding. Unlike the other binding context properties, <code>$index</code> is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</p>
</li>

<li>
<p><code>$parentContext</code></p>

<p>This refers to the binding context object at the parent level. This is different from <code>$parent</code>, which refers to the <em>data</em> (not binding context) at the parent level. This is useful, for example, if you need to access the index value of an outer <code>foreach</code> item from an inner context (usage: <code>$parentContext.$index</code>). This is undefined in the root context.</p>
</li>
</ul>

<p>The following special variables are also available in bindings, but are not part of the binding context object:</p>

<ul>
<li>
<p><code>$context</code></p>

<p>This refers to the current binding context object. This may be useful if you want to access properties of the context when they might also exist in the view model, or if you want to pass the context object to a helper function in your view model.</p>
</li>

<li>
<p><code>$element</code></p>

<p>This is the element DOM object (for virtual elements, it will be the comment DOM object) of the current binding. This can be useful if a binding needs to access an attribute of the current element. Example:</p>

<pre><code>  &lt;div id=&quot;item1&quot; data-bind=&quot;text: $element.id&quot;&gt;&lt;/div&gt;</code></pre>
</li>
</ul>

